version: '3'

silent: true

tasks:
  help:
    desc: Detailed help
    cmds:
      - |
        echo "Tasks:"
        task --list
        echo ""
        echo "Environment:"
        echo "  DOCKER_NAME={{.DOCKER_NAME}}  DOCKER_USERNAME={{.DOCKER_USERNAME}}"
        echo "  GHRC_NAME={{.GHRC_NAME}}  GITHUB_USERNAME={{.GITHUB_USERNAME}}"
        echo "  LAST_RELEASE={{.LAST_RELEASE}}"  VERSION={{.VERSION}}   VERSION_FULL={{.VERSION_FULL}}
        echo "  BRANCH={{.GIT_BRANCH}}  GIT_SHORT_SHA={{.GIT_SHORT_SHA}}"  GIT_SHA={{.GIT_SHA}}

  version:tag-release:
    internal: true
    desc: Create set of git tags
    cmds:
      - |
        set -eu
        if (set -o | grep -q pipefail) 2>/dev/null; then set -o pipefail; fi

        REMOTE='origin'
        FULL='{{.VERSION_FULL}}'
        MINOR='{{.VERSION_MINOR}}'
        MAJOR='{{.VERSION_MAJOR}}'

        # Validate vX.Y.Z
        if ! printf "%s" "$FULL" | grep -Eq '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "❌ ERROR: VERSION '$FULL' must match vX.Y.Z" >&2
          exit 1
        fi

        tag_sha() { git rev-parse "refs/tags/$1" 2>/dev/null || true; }
        remote_tag_sha() { git ls-remote --tags "$REMOTE" "refs/tags/$1" 2>/dev/null | awk '{print $1}' || true; }

        echo "ℹ️ INFO: Tags - Full: $FULL | Minor: $MINOR | Major: $MAJOR"

        # Full tag: must NOT exist on remote; fail fast if it does
        full_remote_sha="$(remote_tag_sha "$FULL")"
        if [ -n "$full_remote_sha" ]; then
          echo "❌ ERROR: Full tag '$FULL' already exists on remote; aborting" >&2
          exit 1
        fi

        # Create full tag locally (if missing) and push
        if git rev-parse --quiet --verify "refs/tags/$FULL" >/dev/null 2>&1; then
          echo "ℹ️ INFO: Full tag '$FULL' exists locally but not on remote; pushing"
        else
          echo "ℹ️ INFO: Creating full tag '$FULL'"
          git tag --annotate "$FULL" --message "$FULL"
        fi
        git push "$REMOTE" "refs/tags/$FULL"
        echo "✅ OK: Pushed full tag '$FULL'"

        # Minor tag: create or update
        git tag --force --annotate "$MINOR" --message "$FULL"
        minor_local_sha="$(tag_sha "$MINOR")"
        minor_remote_sha="$(remote_tag_sha "$MINOR")"
        if [ -z "$minor_remote_sha" ]; then
          git push "$REMOTE" "refs/tags/$MINOR"
          echo "✅ OK: Created and pushed minor tag '$MINOR' -> $minor_local_sha"
        else
          if [ "$minor_local_sha" != "$minor_remote_sha" ]; then
            echo "⚠️ WARN: Updating remote minor tag '$MINOR' to $minor_local_sha (was $minor_remote_sha)"
            git push --force "$REMOTE" "refs/tags/$MINOR"
          else
            echo "ℹ️ INFO: Minor tag '$MINOR' already up-to-date"
          fi
        fi

        # Major tag: create or update
        git tag --force --annotate "$MAJOR" --message "$FULL"
        major_local_sha="$(tag_sha "$MAJOR")"
        major_remote_sha="$(remote_tag_sha "$MAJOR")"
        if [ -z "$major_remote_sha" ]; then
          git push "$REMOTE" "refs/tags/$MAJOR"
          echo "✅ OK: Created and pushed major tag '$MAJOR' -> $major_local_sha"
        else
          if [ "$major_local_sha" != "$major_remote_sha" ]; then
            echo "⚠️ WARN: Updating remote major tag '$MAJOR' to $major_local_sha (was $major_remote_sha)"
            git push --force "$REMOTE" "refs/tags/$MAJOR"
          else
            echo "ℹ️ INFO: Major tag '$MAJOR' already up-to-date"
          fi
        fi

  version:set:
    desc: Update version in README.md and action.yml
    cmds:
      - |
        # check if VERSION if different than VERSION_FROM_ACTION_YML
        if [ "{{.VERSION}}" = "{{.VERSION_FROM_ACTION_YML}}" ]; then
          echo "❌ ERROR: VERSION is same as VERSION_FROM_ACTION_YML ({{.VERSION}})"
          exit 1
        fi
      - echo Updating full version from {{.VERSION_FROM_ACTION_YML}} to {{.VERSION}}
      - echo Updating minor version from {{.MINOR_FROM_ACTION_YML}} to {{.VERSION_MINOR}}
      - echo Updating major version from {{.MAJOR_FROM_ACTION_YML}} to {{.VERSION_MAJOR}}
      - "{{.SED}} -i 's#{{.DOCKER_NAME}}:{{.VERSION_FROM_ACTION_YML}}#{{.DOCKER_NAME}}:{{.VERSION}}#g' action.yml"
      - "{{.SED}} -i 's#{{.DOCKER_NAME}}@{{.VERSION_FROM_ACTION_YML}}#{{.DOCKER_NAME}}@{{.VERSION}}#g' README.md"
      - "{{.SED}} -i 's#{{.GITHUB_NAME}}@{{.VERSION_FROM_ACTION_YML}}#{{.GITHUB_NAME}}@{{.VERSION}}#g' README.md"
      - "{{.SED}} -i 's#{{.DOCKER_NAME}}@{{.MINOR_FROM_ACTION_YML}}#{{.DOCKER_NAME}}@{{.VERSION_MINOR}}#g' README.md"
      - "{{.SED}} -i 's#{{.GITHUB_NAME}}@{{.MINOR_FROM_ACTION_YML}}#{{.GITHUB_NAME}}@{{.VERSION_MINOR}}#g' README.md"
      - "{{.SED}} -i 's#{{.DOCKER_NAME}}@{{.MAJOR_FROM_ACTION_YML}}#{{.DOCKER_NAME}}@{{.VERSION_MAJOR}}#g' README.md"
      - "{{.SED}} -i 's#{{.GITHUB_NAME}}@{{.MAJOR_FROM_ACTION_YML}}#{{.GITHUB_NAME}}@{{.VERSION_MAJOR}}#g' README.md"

  lint:actionlint:
    desc: Lint GitHub Actions workflows with actionlint
    cmds:
      - |
        echo "▶️ Running actionlint..."
        set +e
        docker run --rm -i -v "$PWD:/work" -w /work rhysd/actionlint:latest -color
        rc=$?
        set -e
        if [ "$rc" -eq 0 ]; then
          echo "✅ actionlint passed"
        else
          echo "❌ actionlint failed"
          exit $rc
        fi

  lint:hadolint:
    desc: Lint Dockerfile with hadolint
    cmds:
      - |
        echo "▶️ Running hadolint..."
        set +e
        docker run --rm -i -v "$PWD:/work" -w /work hadolint/hadolint:latest-debian < Dockerfile
        rc=$?
        set -e
        if [ "$rc" -eq 0 ]; then
          echo "✅ hadolint passed"
        else
          echo "❌ hadolint failed"
          exit $rc
        fi

  lint:shellcheck:
    desc: Lint shell scripts with shellcheck
    cmds:
      - |
        echo "▶️ Running shellcheck..."
        set +e
        docker run --rm -i -v "$PWD:/work" -w /work koalaman/shellcheck:stable -x -S style entrypoint.sh
        rc=$?
        set -e
        if [ "$rc" -eq 0 ]; then
          echo "✅ shellcheck passed"
        else
          echo "❌ shellcheck failed"
          exit $rc
        fi

  lint:yamllint:
    desc: Lint YAML files with yamllint
    cmds:
      - |
        echo "▶️ Running yamllint..."
        set +e
        docker run --rm -i -v "$PWD:/work" -w /work cytopia/yamllint -c .yamllint.yml .
        rc=$?
        set -e
        if [ "$rc" -eq 0 ]; then
          echo "✅ yamllint passed"
        else
          echo "❌ yamllint failed"
          exit $rc
        fi

  docker:build:inspect:
    desc: Inspect built Docker image
    cmds:
      - |
        image_inspect_out=$(docker image inspect {{.DOCKER_NAME}}:{{.VERSION_FULL}}{{.VERSION_SUFFIX}} | jq -r)
        echo -e "\nℹ️ Docker image inspect:"
        echo "$image_inspect_out" | jq

  docker:push:inspect:
    desc: Inspect built Docker image
    cmds:
      - |
        set -eu
        image="{{.DOCKER_NAME}}:{{.VERSION_FULL}}{{.VERSION_SUFFIX}}"

        echo -e "\nℹ️ Trying local image inspect: $image"
        set +e
        image_inspect_out=$(docker image inspect "$image" 2>/dev/null || true)
        rc=$?
        set -e

        # Validate that docker inspect returned a non-empty array with an Id
        has_local=0
        if [ "$rc" -eq 0 ] && [ -n "$image_inspect_out" ]; then
          if echo "$image_inspect_out" | jq -e 'type=="array" and (length > 0) and \
              (.[0].Id != null and .[0].Id != "")' >/dev/null 2>&1; then
            has_local=1
          fi
        fi

        if [ "$has_local" -eq 1 ]; then
          echo -e "\n✅ Local image found. Docker image inspect:"
          echo "$image_inspect_out" | jq
          image_sha=$(echo "$image_inspect_out" | jq -r '.[0].Id // empty')
          if [ -n "$image_sha" ]; then
            echo -e "\nℹ️ Docker manifest inspect (local):"
            docker manifest inspect "${image}@${image_sha}" | jq || true
          fi
          exit 0
        fi

        echo -e "\nℹ️ Local image not found or inspect returned empty; inspecting remote with buildx imagetools..."
        set +e
        raw=$(docker buildx imagetools inspect --raw "$image" 2>/dev/null || true)
        set -e

        if [ -z "$raw" ]; then
          echo "❌ Failed to inspect remote image with buildx imagetools: $image"
          exit 1
        fi

        echo -e "\n✅ Remote manifest/index (raw):"
        echo "$raw" | jq

        echo -e "\nℹ️ Attempting to pull and inspect per-platform manifests:"
        echo "$raw" | jq -r '.manifests[]?.digest' | while IFS= read -r digest; do
          if [ -z "$digest" ] || [ "$digest" = "null" ]; then
            continue
          fi
          ref="${image%@*}@${digest}"
          echo -e "\nℹ️ Pulling $ref (may fail for some registries)..."
          set +e
          docker pull "$ref" >/dev/null 2>&1 || true
          pulled_rc=$?
          set -e
          if [ "$pulled_rc" -eq 0 ]; then
            echo "ℹ️ Inspecting pulled image $ref"
            docker image inspect "$ref" | jq || true
          else
            echo "⚠️ Could not pull $ref; skipping image inspect"
          fi
        done

  git:get-pr-template:
    desc: Get pull request template
    cmds:
      - mkdir -p .tmp
      - curl -LsS https://raw.githubusercontent.com/devops-infra/.github/master/PULL_REQUEST_TEMPLATE.md -o .tmp/PULL_REQUEST_TEMPLATE.md

  git:set-config:
    desc: Set git user config
    cmds:
      - git config user.name "github-actions[bot]"
      - git config user.email "github-actions[bot]@users.noreply.github.com"
